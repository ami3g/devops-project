# GitHub Actions workflow for building, scanning, and deploying a Docker image
#
name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: devops-project-app
  IMAGE_TAG: ${{ github.sha }}

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Set image environment variables
        id: set-image-vars
        run: |
          echo "ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}" >> $GITHUB_ENV
          echo "LATEST_IMAGE_NAME=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest" >> $GITHUB_ENV

      - name: Build Docker image
        run: |
          docker build -t $IMAGE_NAME .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          # Tells Trivy to scan the image we just built.
          image-ref: ${{ env.IMAGE_NAME }}
          # Formats the output as a table for easy reading in the logs.
          format: 'table'
          # Only report vulnerabilities with CRITICAL or HIGH severity.
          severity: 'CRITICAL,HIGH'
          # Fail the pipeline if any CRITICAL or HIGH severity vulnerabilities are found.
          exit-code: '1' 

      - name: Push image to Amazon ECR
        run: |
          docker push $IMAGE_NAME

      - name: Tag and push image with 'latest' tag
        run: |
          docker tag $IMAGE_NAME $LATEST_IMAGE_NAME
          docker push $LATEST_IMAGE_NAME

      - name: Find Launch Template ID
        id: get-launch-template-id
        run: |
          LAUNCH_TEMPLATE_ID=$(aws ec2 describe-launch-templates --filters "Name=tag:Name,Values=devops-project-app-template" --query "LaunchTemplates[0].LaunchTemplateId" --output text)
          echo "LAUNCH_TEMPLATE_ID=$LAUNCH_TEMPLATE_ID" >> $GITHUB_ENV
          if [ "$LAUNCH_TEMPLATE_ID" = "None" ]; then
            echo "Launch template not found. Exiting."
            exit 1
          fi

      - name: Update Launch Template with new image
        run: |
          aws ec2 create-launch-template-version \
          --launch-template-id ${{ env.LAUNCH_TEMPLATE_ID }} \
          --source-version '$Latest' \
          --launch-template-data '{"ImageId":"ami-00ca32bbc84273381"}'

      - name: Find Auto Scaling Group Name
        id: get-asg-name
        run: |
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --filters "Name=tag:Name,Values=devops-project-asg" --query "AutoScalingGroups[0].AutoScalingGroupName" --output text)
          echo "ASG_NAME=$ASG_NAME" >> $GITHUB_ENV
          if [ "$ASG_NAME" = "None" ]; then
            echo "Auto Scaling Group not found. Exiting."
            exit 1
          fi

      - name: Force new deployment on Auto Scaling Group
        run: |
          # Wait for any previous instance refresh to complete
          MAX_WAIT_TIME=300 # seconds
          ELAPSED_TIME=0
          while [ $ELAPSED_TIME -lt $MAX_WAIT_TIME ]; do
            REFRESH_STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name ${{ env.ASG_NAME }} \
              --query "InstanceRefreshes[0].Status" --output text)
            
            if [[ "$REFRESH_STATUS" == "None" || "$REFRESH_STATUS" == "Successful" || "$REFRESH_STATUS" == "Cancelled" || "$REFRESH_STATUS" == "Failed" ]]; then
              echo "Previous instance refresh is complete. Proceeding with new refresh."
              break
            fi
            
            echo "Instance refresh is in progress. Waiting..."
            sleep 10
            ELAPSED_TIME=$((ELAPSED_TIME + 10))
          done
          
          if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Timed out waiting for previous instance refresh to complete. Exiting."
            exit 1
          fi
          
          aws autoscaling start-instance-refresh --auto-scaling-group-name ${{ env.ASG_NAME }}